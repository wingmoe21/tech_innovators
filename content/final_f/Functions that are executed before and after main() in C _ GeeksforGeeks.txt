Transcript of the audio for the lecture:
0.23 - 7.954:  Friends today in this video we will discuss about the functions that are executed before and after main function in C programming language.
10.075 - 10.775: So let us start.
11.155 - 16.838: So this is the program through which we will understand the constructor and destructor part in C programming language.
18.959 - 25.302: So in this program as we can see that there is a constructor defined and there is a destructor defined.
25.982 - 29.704: So whenever our main function will be executed first of all
30.413 - 35.778:  Our constructor will be called and in the constructor this function is defined.
36.418 - 37.94: So this function will be executed.
38.76 - 43.384: So it will execute this printf statement and it will print start up code before main.
44.005 - 47.448: So this line will be printed at first location.
48.549 - 53.953: Then what will happen then main function will be executed and it will print hello.
54.714 - 58.137: Okay so at the second printf statement hello will be printed.
60.171 - 61.972:  So after that it will return 0.
63.574 - 65.055: Then main function will be ended.
65.435 - 72.04: After that our destructor will be called and in the destructor part this function is defined myCleanupFun.
72.841 - 81.307: So it will call this function myCleanupFun and inside this function we will print this printf statement clean up code after main.
81.728 - 83.909: So in the end this line will be executed.
84.41 - 89.834: So output will be start up code before main then hello
90.481 - 92.563:  and after that clean up code after me.
93.284 - 99.27: We will see the program output in .cpp file also.
99.85 - 100.391: Let us start.
107.238 - 109.44: So this is the program which we are watching.
109.901 - 112.343: So let us run this program and we will see the output.
144.335 - 151.598:  So as you can see the output is start up code before main then hello then clean up code after main.
151.918 - 159.181: So first of all our constructor function has been called then main function and after that destructor function will be called.
160.441 - 165.544: So this is the sequence of constructor and destructor before main and after main.
170.786 - 171.706: Thank you for watching.


The content from the lecture slides:
Page 1: The image showcases a PowerPoint presentation slide featuring a coding example. The code includes a C program which demonstrates the use of constructor and destructor attributes. Specifically, the attributes are applied to the functions `myStartupFun(void)` and `myCleanupFun(void)`, so that `myStartupFun` executes before `main()` and `myCleanupFun` executes after `main()`. The implementation of these functions includes simple `printf` statements to indicate when they are being called relative to the `main()` function, which itself just prints "hello" to the standard output.

Page 2: This image shows a thumbnail view inside a PowerPoint presentation software window that displays three slides. The main focus is on the second slide, which replicates the information from the first image, showing a piece of code in C that utilizes constructor and destructor attributes.

Page 3: The image shows a full view of the second slide from the PowerPoint presentation previously seen in thumbnail form, which contains the same code example demonstrating the application of constructor and destructor attributes in a C program.

Page 4: Similar to the first image, the image clearly presents a C program to illustrate the function of constructor and destructor attributes. The code comments indicate where and how to use these attributes within the code, and a small implementation is provided showing the messages printed during the program execution lifecycle.

Page 5: This is an overview of a PowerPoint application window with three slides visible in the thumbnails pane. The selected slide demonstrates functions in C that execute before and after the `main()` function, with the detailed code example shown on the right side of the window.

Page 6: This image shows the same PowerPoint slide presentation window as the previous image, with a focus on the second slide, identical to the program code presented in Page 3. The slide title mirrors the same content, framing the usage of constructor and destructor attributes in the C programming language.

Page 7: We see the C program code in a text editor again, laid out as described in Page 1 and Page 4. This view provides a straightforward representation of how the constructor and destructor attributes are applied in a simple C program to control the execution timing of functions in relation to the `main()` function.

Page 8: The image shows an IDE or text editor with the C code displaying the use of constructor and destructor attributes before and after `main()`. The format and content match the C program detailed in the earlier images.

Page 9: This image, displaying a computer command prompt window overlapping the C code in a text editor, reiterates the application of constructor and destructor attributes in a C program. The command prompt window does not contribute to the explanation but suggests an environment where the C program might be compiled and executed.

Page 10: A final slide in a PowerPoint presentation with a "Thank you for watching" message, indicating the conclusion of the lecture or presentation. No technical content is provided here, only an invitation for comments or feedback.
Question: How to deallocate dynamically allocate memory without using "free()" function.
Solution: Standard library function realloc() can be used to deallocate previously allocated memory. Below is
function declaration of "realloc()" from "stdlib.h"
void *realloc(void *ptr, size_t size);
Note:
If "size" is zero, then call to realloc is equivalent to "free(ptr)". And if "ptr" is NULL and size is non-zero then
call to realloc is equivalent to "malloc(size)"./* code with memory leak */
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
}
int *ptr = (int*) malloc(10);
return 0;
[narendra@ubuntu]$ valgrind -leak-check-full ./free
==1238== LEAK SUMMARY:
==1238== definitely lost: 10 bytes in 1 blocks.
==1238==
possibly lost: 0 bytes in 0 blocks.
==1238== still reachable: 0 bytes in 0 blocks.
==1238==
suppressed: 0 bytes in 0 blocks.
[narendra@ubuntu]$#include <stdio.h>
#include <stdlib.h>
int main(void)
{
}
int *ptr = (int*) malloc(10);
/* we are calling realloc with size = 0 */
realloc(ptr, 0);
return 0;
[narendra@ubuntu]$ valgrind -leak-check=full ./a.out
==1435== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 11 from 1)
==1435== malloc/free: in use at exit: 0 bytes in 0 blocks.
==1435== malloc/free: 1 allocs, 1 frees, 10 bytes allocated.
==1435== For counts of detected errors, rerun with: -v
==1435== All heap blocks were freed - no leaks are possible.
[narendra@ubuntu]$/* code with memory leak */
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
}
int *ptr = (int*)malloc(10);
return 0;
[narendra@ubuntuls valgrind -leak-check-full./free
==1238== LEAK SUMMARY:
==1238==
==1238== definitely lost: 10 bytes in 1 blocks.
possibly lost: 0 bytes in 0 blocks.
==1238== still reachable: 0 bytes in 0 blocks.
==1238==
suppressed: 0 bytes in 0 blocks.
[narendra@ubuntu]$#include <stdio.h>
#include <stdlib.h>
int main(void)
{
}
int *ptr = (int*) malloc(10);
/* we are calling realloc with size = 0 */
realloc(ptr, 0);
fre (ha)
return 0;
[narendra@ubuntu] valgrind -leak-check-full ./a.out
==1435== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 11 from 1)
==1435== malloc/free: in use at exit: 0 bytes in 0 blocks.
==1435== malloc/free: 1 allocs, 1 frees, 10 bytes allocated.
==1435== For counts of detected errors, rerun with: -v
==1435== All heap blocks were freed - no leaks are possible.
[narendra@ubuntu]$∆èG
Thank you for watching!
Please leave us your comments.