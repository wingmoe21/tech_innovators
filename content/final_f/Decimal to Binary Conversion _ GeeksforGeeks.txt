Transcript of the audio for the lecture:
0.273 - 2.454:  Hello friends, welcome to GeeksforGeeks.
3.015 - 8.358: In this tutorial, we are going to see how to convert a decimal number to a binary number.
9.199 - 27.611: A binary number is a number expressed in the base 2 numeral system or binary numeral system, which uses only two symbols that are 0 and 1, whereas a decimal number is a number expressed in the base 10 and requires 10 different numerals, the digits 0 to 9.
28.74 - 33.242:  Now let us look at the algorithm to convert a decimal number to a binary number.
34.342 - 34.922: Step 1.
35.423 - 39.044: Store the remainder when the number is divided by 2 in an array.
39.964 - 40.485: Step 2.
40.745 - 41.825: Divide the number by 2.
42.765 - 43.086: Step 3.
43.746 - 47.287: Repeat the above two steps until the number is greater than 0.
47.867 - 50.148: Let us look at these steps in an example.
50.468 - 52.329: Let the decimal number be 17.
53.129 - 53.409: Step 1.
53.69 - 54.65: We make an array.
55.35 - 57.191:  Step 2, we divide the number by 2.
57.891 - 61.672: We repeat these steps again and again until we get a number greater than 0.
62.493 - 65.434: Therefore, 8 divided by 2 will give 4 with remainder 0.
65.794 - 69.415: 4 divided by 2 will give 2 with remainder 0.
70.095 - 72.276: 2 divided by 2 will give 1 with remainder 0.
73.377 - 75.657: 1 divided by 2 will give 0 with remainder 1.
76.558 - 80.339: Now that we have reached 0, we print the array in reverse order i.e.
80.399 - 80.339: 1 0 0 0 1.
83.536 - 89.22:  Therefore the binary equivalent of the decimal number 17 is 10001.
89.86 - 91.161: Now let us look at the code.
92.221 - 97.645: The function decimalToBinary takes the decimal number and prints its binary equivalent.
98.245 - 102.248: First of all we take an array binary number to store the binary number.
102.788 - 105.75: Then we have i which is a counter for the binary array.
106.29 - 108.812: Now we run a while loop until n is greater than 0.
109.793 - 114.876:  We take out the remainder of n when it is divided by 2 and store it in the binary array.
115.336 - 120.579: Then we change the value of n by dividing it by 2 and incrementing the value of i by 1.
121.339 - 124.461: We continue doing these steps until n is greater than 0.
125.201 - 129.363: After exiting the loop, we print the array binary num in its reverse order.
130.004 - 132.145: Let us understand the code with an example.
133.226 - 135.247: Suppose we have the value of n as 17.
136.405 - 140.387:  Initially binary number will be empty and the value of i is 0.
141.267 - 144.628: As n is greater than 0 we can go inside the while loop.
145.189 - 148.87: Here n modulus 2 that is 17 modulus 2 gives 1.
149.35 - 152.572: Therefore we put the value 1 in the binary number array.
153.252 - 155.873: Now we change the value of n by dividing it by 2.
156.273 - 161.616: Therefore 17 divided by 2 will give 8 and then we will increase the value of i by 1.
162.216 - 164.957: As n is still greater than 0 we continue the loop.
165.643 - 192.278:  now n modulus 2 that is 8 modulus 2 is 0 therefore we put it in the binary number array we change the value of n by dividing it by 2 8 divided by 2 will give us 4 and we will increase the value of i by 1 now the value of i is 2 as the value of n is still greater than 0 we will continue the loop here n modulus 2 that is 4 modulus 2 will give us 0 we add 0 to the array
192.836 - 195.458:  Now we will change the value of n by dividing it by 2.
195.758 - 197.919: 4 divided by 2 will give us 2.
198.599 - 200.56: We increment the value of i by 1.
200.821 - 202.221: From 2, it's become 3.
202.762 - 206.484: As the value of n is still greater than 0, we continue these steps.
206.964 - 211.567: In the next iteration again, n modulus 2, that is, 2 modulus 2 will give us 0.
212.487 - 215.449: We change the value of n by dividing it by 2.
215.729 - 217.81: 2 divided by 2 will give us 1.
218.31 - 220.732: We increment the value of i, which gives us 4.
221.514 - 224.776:  As the value of n is still greater than 0, we continue the loop.
225.277 - 232.482: n modulus 2, that is 1 modulus 2, will give us 1. n divided by 2, that is 1 divided by 2, will give us 0.
232.862 - 234.544: We increase the value of i to 5.
235.564 - 246.692: Now, as the value of n is not greater than 0, we can exit the loop and print the binary number array in its reverse order to get the binary equivalent of 17, that is 1 0 0 0 1.
249.054 - 250.315: Hope you understood the code.
250.888 - 251.69:  Thanks for watching.
251.871 - 253.013: Please leave us your comments.


The content from the lecture slides:
Page1: This slide presents a C language code snippet and discusses the order of evaluation of function arguments, which can vary depending on the compiler. It highlights the ambiguity involved in the evaluation order when using post-increment operators in function arguments, as shown in the code where `func(i++, i++)` is used. The main point is that it is not safe to rely on the order of side effects because different compilers may evaluate arguments from left to right or right to left, which can lead to different results.
Page2: This is a closing slide, typically shown at the end of a presentation, which says "Thank you for watching! Please leave us your comments." It doesn't contain educational content.
Page3: This slide seems to be a duplicate of Page 2, also showing a closing statement with a "Thank you for watching! Please leave us your comments." message.
Page4: This appears to be another instance of the technical content slide present in Page 1, discussing C programming language specifics related to function argument evaluation order and the potential unpredictability due to compiler differences.
Page5: This appears to be a repeated image of the closing slide, the same as Page 2 and Page 3, with the message "Thank you for watching! Please leave us your comments."
=> 110₂ = (1×2²) + (1×2¹) + (0*2⁰)
=> 110₂ = 4 + 2 + 0
=> 110₂
Slide 2
=
6
Algorithm
AL
1.
2.
3.
Multiply each digit separately from
left to right by 2^0, 2^1, 2^2.…..
respectively.
Add all the results coming from step
1.
Equivalent decimal number would be
the result obtained in step 2.
Google Slides// Function to convert binary to decimal
int binaryToDecimal(int n)
}
int num= n;
int dec_value = 0;
// Initializing base value to 1, i.e 2^0
int base = 1;
int temp = num;
while (temp) {
}
int last_digit = temp % 10;
temp = temp / 10;
dec_value += last_digit * base;
base = base * 2;
return dec_value;
Slide 3
AL
Code
num = 110
base = 1
Dry Run
Input: 110
dec_value = 0
temp = 110
last_dig = 0_last_dig = 1
temp = 11
temp = 1
dec_val=0
dec_val= 2
base = 2
base = 4
last_dig = 1
temp = 0
dec_val = 6
base = 8
Output: 6
Google Slides// Function to convert binary to decimal
int binaryToDecimal(int n)
{
}
int num = n;
int dec_value = 0;
// Initializing base value to 1, i.e 2^0
int base = 1;
int temp = num;
while (temp) {
}
int last_digit = temp % 10;
temp = temp / 10;
dec_value += last_digit * base;
base = base * 2;
return dec_value;
Slide 3 Y
Code
num = 110
base = 1
Dry Run
Input: 110
dec_value = 0
temp = 110
last_dig = 0_last_dig = 1_last_dig = 1
temp = 11
temp = 1
dec_val = 0
temp = 0
dec_val= 2 dec_val = 6
base = 8
base = 2
base = 4
Output: 6
Google Slides.Waiting for docs.google.com...
DG
Thank you for watching!
Please leave us your comments.
Google Slides