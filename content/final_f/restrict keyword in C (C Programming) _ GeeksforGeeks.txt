Transcript of the audio for the lecture:
0.25 - 28.908:  friends today in this video we will discuss about a restrict keyword in C so in the C programming language after 99 standard a new keyword is introduced whose name is restrict so restrict keyword is mainly used in pointer declarations as a type qualifier for pointers only type qualifier it does not add any new functionality
29.645 - 37.251:  It is only a way for programmer to inform about an optimization that compiler can make.
40.473 - 56.686: When we use restrict with the pointer ptr, it tells the compiler that ptr is the only way to access the object pointed by it and the compiler does not need to add any additional checks.
60.29 - 70.856:  If the programmer uses restrict keyword and violate the above conditions, then definitely result is undefined behavior.
73.897 - 78.32: And the last point is a restrict keyword will not be supported by C++.
79.18 - 82.722: It is a C only keyword.
85.684 - 86.784: So this is the program.
88.545 - 89.846: Let us analyze this program.
92.523 - 119.289:  so we have a main method then we have three variables a value is 50 b value is 60 and c value is 70 then we are sending address of a address of b and address of c in use function then it will go here in the use function here address of a will be stored here address of b will be stored and here address of c will be stored
120.336 - 148.93:  here we have defined restrict keyword right so this restrict keyword does not change anything in output because it is just a way for the programmer to tell the compiler about some optimizations in assembly language or in assembly code okay so what we are doing in this line we are doing star a is equal to star a plus star c
150.103 - 177.73:  so star a is 50 and star c will be 70 and they are updating the value of star a so star a will be 70 plus 50 120 okay then in the next line what we are doing star b is equal to star b plus star c means they are updating the value of b with b plus c so b plus c will be
179.4 - 207.514:  130 so it will be updated by 130 now what we are doing we are printing value of a b and c so it will print 120 130 and 70 so in this program using restrict keyword we are just telling the compiler that do not reload value at address c in its assembly code and if you will note
208.135 - 217.3:  use this restrict keyword then definitely compiler will reload the value at address c in its assembly code language.
218.881 - 226.345: Therefore, we can say using restrict keyword we have generated assembly code which is optimized in nature.
228.346 - 235.89: So it will not change the output of the code it will just change the order of the optimizations in compiler.
239.947 - 240.922:  Thank you for watching.


The content from the lecture slides:
Page1: The slide presents a problem statement that involves writing a program to convert a given decimal number into its equivalent octal number. This means translating a number from base 10 to base 8.

Page2: The problem statement continues, providing more context to the nature of number systems, specifying that different bases use different numbers of digits, with binary (base 2) using two digits (0 and 1), and decimal (base 10) using ten digits (0-9).

Page3: The algorithm slide explains the process for converting a decimal number to its octal equivalent. The steps are to store the remainder of the division by 8 in an array, divide the number by 8, repeat these steps until the number is zero, and finally, print the array in reverse order. An example with the decimal number 33 is provided, showing its conversion to the octal number 41.

Page4: This slide contains the code implementation in C language of the previously explained algorithm. The function 'decToOctal' is responsible for taking an integer value 'n' as input, storing the conversion result into an array 'octalNum,' and then printing the octal number in reverse order due to the division method effectively building the octal number in reverse.

Page5: A dry run of the code is shown for when the input 'n' is the decimal number 33. It illustrates how the array 'octalNum' is populated and the value of the counter 'i' as the loop iterates. After the loop completes, the array will contain the octal equivalent of the decimal number in reverse order.

Page6: The final slide is a thank-you note and a request for comments, signaling the end of the presentation.

Page7: An image of a text editor with C code unrelated to the previous content, showing an example of a program with constructor and destructor attributes used in functions before and after main, respectively.

Page8: The presentation slide deck overview depicting slides 1 to 3, which correspond to the code snippet about constructor and destructor attributes in a program.

Page9: A single-page overview of the slide deck with an emphasis on a “Thank You” slide, marking the conclusion of the presentation.
Problem Statement :
Given :
A cost matrix cost[] (All costs are positive)
O Position (m, n) in cost[][]
O
Write a function that returns cost of minimum cost path to reach (m, n) from
(0, 0).
O
Total cost of a path to reach (m, n) is sum of all the costs on that path
(including both source and destination)Allowed movements :
Can only traverse up, right and diagonally upper cells from a given cell.
From a given cell (i, j)
(i+1,
(i, j+1)
(i+1, j+1)
A A A
j)2
1
0
1
4
1
0
5
8
2
1
2
3
2
31
4
1
5
8
2
3
2
3
Minimum cost:
1+2+2+3 = 8Optimal Substructure:
The path to reach (m, n) :
Through one of the 3 cells: (m-1, n-1) or (m-1, n) or (m, n-1).
→ minCost(m, n) = min (minCost(m-1, n-1), minCost(m-1, n), minCost(m, n-1))
+ cost[m][n]/* Returns cost of minimum cost path from (0,0) to (m, n
int minCost(int cost [R] [C], int m, int n)
{
|1}
if (n < 0 || m < 0)
return INT MAX;
else if (m == 0 && n == 0)
return cost [m][n];
else
return cost [m][n] + min( minCost (cost, m-1, n-1),
minCost(cost, m-1, n),
minCost (cost, m, n-1) );Time complexity of this naive
recursive solution is exponential!mC refers to minCost()
/
Overlapping Subproblems
/
mC (1, 1)
|
1
mC(2, 2)
I
|
mC (1, 2)
/
|
|
1
mC (0,0) mC (0,1) mC (1,0) mC (0,1) mC (0,2) mC (1,1) mC (1,0)
1
mC (2,
/
/
1)
1
|
|
mC (1,1) mC (2,0)So the problem has :
Optimal Substructure
and
Overlapping subproblems
Dynamic Programming
Constructing a temporary array t
in bottom up manner.2
1
О
1
4
1
О
5
8
2
1
2
3
2
32
1
1 4
0
1
0
Cost
5
8
2
1
3
2
3
2
2
İ ₁
1
0
0
1
tc
j
2{
}
int i, j;
// Instead of following line, we can use int tc[m+1] [n+1] or
// dynamically allocate memory to save space. The following line is
// used to keep the program simple and make it working on all compile
int tc[R] [C];
tc[0][0] = cost[0][0];
/* Initialize first column of total cost(tc) array */
for (i = 1; i <= m; i++)
tc[i][0] = tc[i-1][0] + cost[i][0];
/* Initialize first row of tc array */
for (j = 1; j <= n; j++)
tc[0][j] = tc[0][j-1] + cost[0][j];
/* Construct rest of the tc array */
for (i = 1; i <= m; i++)
for (j = 1; j <= n; j++)
tc[i][j] = min (tc[i-1] [j-1],
tc[i-1][j],
return tc[m][n];
tc[i][j-1]) + cost[i][j];Time
Complexity
0(m * n)Thank You for watching !
Please leave us your likes and comments.