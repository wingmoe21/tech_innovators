Transcript of the audio for the lecture:
0.27 - 0.831:  Hello friends!
1.171 - 2.292: Welcome to GeeksforGeeks.
2.852 - 8.157: In this tutorial, we are going to see how to convert an octal number to a decimal number.
8.998 - 20.509: The problem statement is, given an octal number as input, we need to write a program to convert the given octal number into the equivalent decimal number i.e.
20.629 - 23.932: convert the number with base value 8 to base value 10.
25.089 - 31.111:  The base value of a number system determines the number of digits used to represent a numeric value.
31.971 - 36.592: For example, the binary number system uses 2 digits 0 and 1.
37.192 - 46.494: Octal number system uses 8 digits from 0 to 7 and decimal number system uses 10 digits 0 to 9 to represent any numeric value.
47.075 - 48.555: Now let us look at the algorithm.
49.033 - 49.913:  Step 1.
50.233 - 60.435: Multiply each digit separately from left to right by 8 raised to the power 0, 8 raised to the power 1, 8 raised to the power 2 and so on respectively.
60.975 - 61.815: Step 2.
62.335 - 64.856: Add all the results coming from step 1.
65.396 - 66.276: Step 3.
66.796 - 70.277: Equivalent decimal number would be the result obtained in step 2.
70.677 - 73.277: Now let us understand the algorithm by an example.
73.618 - 75.038: Suppose the octal number is 123.
76.434 - 86.596:  Now step number 1 is to multiply each digit separately from left to right, that is 3, 2, 1 by 8 raised to power 0, 8 raised to power 1 and so on.
86.996 - 96.498: So 3 will be multiplied by 8 raised to the power 0, 2 will be multiplied by 8 raised to the power 1 and 1 will be multiplied by 8 raised to the power 2.
97.298 - 100.079: Then we add all the results coming from step number 1.
100.559 - 105.48: So we add 3 plus 16 plus 64 and obtain the decimal number 83.
106.952 - 108.253:  Now let us look at the code.
109.033 - 115.438: In the function octalToDecimal, we have passed an octal number n and it returns its decimal equivalent.
116.038 - 119.38: We initialize numWithN and decimal value as 0.
120.521 - 125.044: We initialize the value of base as 1 which is 8 raised to the power 0.
126.045 - 127.726: We initialize temp as num.
128.346 - 131.849: Now we run a while loop until temp is not equals to 0.
132.754 - 137.916:  Inside the while loop, first of all, we extract the last digit and store it in last digit.
138.417 - 141.938: Then we change the value of temp by dividing it by 10.
142.779 - 148.481: Then we multiply the last digit with appropriate base value and add it to the decimal value.
148.941 - 152.623: In the end, we change the value of base by multiplying it by 8.
153.403 - 156.785: These steps will continue until temp is not equal to zero.
157.305 - 160.927: In the end of the while loop, we finally return the decimal value.
161.573 - 163.555:  Now let us look at this with an example.
164.275 - 165.876: Suppose we have a number 123.
166.297 - 171.44: We initialize num as 123 and decimal value as 0.
172.221 - 176.964: The value of base will be 1 and temp will be initialized as 123.
177.485 - 185.271: In the first iteration the last digit of temp 123 is 3 and we change the value of 123 to 12.
186.331 - 189.894: Now the decimal value will be last digit into base.
190.327 - 192.749:  that is 3 into 1 equals 3.
193.45 - 196.232: Now we change the value of base from 1 to 8.
197.112 - 202.337: In the next iteration, we extract the last digit of temp which is 12 as 2.
203.217 - 207.461: Now we change the value of temp by dividing it by 10 and get 1.
208.141 - 217.409: Now we multiply the base 8 with the last digit 2 which gives 16 and add it to the previous decimal value 3 to obtain the new decimal value 19.
218.467 - 224.49:  We change the value of base by multiplying it by 8 which gives 8 into 8 equals 64.
225.29 - 229.772: As the value of temp is not equal to 0 we continue on to the next iteration.
230.413 - 237.216: Now the last digit of temp will equal to 1 and we change the value of temp from 1 to 0.
238.256 - 245.64: Last digit 1 into base 64 will give 64 and we add that into the decimal value 19 to obtain 83.
246.86 - 249.463:  We change the value of base by multiplying it by 8.
249.963 - 252.546: That is 8 into 64 will now give 512.
253.808 - 257.992: As the value of temp is equal to 0, we can exit the while loop.
258.393 - 261.156: Finally, we can return the decimal value, which is 83.
262.457 - 263.859: I hope you understood the code.
264.399 - 265.36: Thank you for watching.
265.56 - 266.702: Please leave us your comments.


The content from the lecture slides:
Page1: The slide introduces the concept of void pointers in C programming language. It defines a scenario where two variables of different types (int and char) are declared. Then, a void pointer is shown to take the address of both these variables, demonstrating that a void pointer can point to any data type. A graphical representation shows the memory addresses associated with the variables and how the void pointer can hold the address of either. A note at the bottom reiterates that a void pointer can contain the address of a variable of any type.

Page2: This slide presents code snippets that explain how to use void pointers and the importance of typecasting when dereferencing them. The first code piece attempts to print the value at the address pointed to by a void pointer without typecasting, which will result in a compiler error because the compiler needs to know the number of bytes to retrieve. The second code snippet corrects this by explicitly casting the void pointer to an int pointer before dereferencing. The third snippet shows how to move the void pointer to the next integer in an array by adding the size of an int to the pointer and then typecasting it before dereferencing.

Page3: This slide lists two advantages of using void pointers in C. The first point highlights that memory allocation functions such as malloc() and calloc() return a void pointer, which allows them to be used for allocating memory for any data type. The second point mentions that void pointers are used to implement generic functions, such as the compare function in the qsort routine, making them valuable for creating type-independent code in C.

Page4: This final slide seems to be a closing slide with a message thanking the viewer for watching the presentation and inviting them to leave comments. No informative content related to the lecture topic is present on this slide.
Dangling pointer:
A pointer pointing to a memory location that has been already deleted is called
dangling pointer.
// Deallocating a memory pointed by ptr causes
// dangling pointer
#include <stdlib.h>
#include <stdio.h>
int main()
{
}
int *ptr = (int *)malloc(sizeof(int));
// After below free call, ptr becomes a
// dangling pointer
free (ptr);
// No more a dangling pointer
ptr = NULL;
ptr = NULL
700
ptr = 100
700
ptr = 100
700
Dangling pointer
1 byte 1 byte 1 byte
100 200
300
1 byte
100
1 byte
200
1 byte
CUO
1 byte
400
1 byte
400Dangling pointer ...
// The pointer pointing to local variable becomes
// dangling when local variable is not static.
#include<stdio.h>
int *fun()
{
// x is local variable and goes out of
// scope after an execution of fun() is
// over.
int x = 5;
return &x;
}
// Driver Code
int main()
{
}
int *p = fun();
fflush(stdin);
// p points to something which is not
// valid anymore
printf("%d", *p);
return 0;
x=5
100
Local
memory
p=fun() = 100
300
printf *p → garbage
Output:
garbage
Int *fun()
Int main()Dangling pointer ...
// The pointer pointing to local variable doesn't
// become dangling when local variable is static.
#include<stdio.h>
int *fun()
{
// x now has scope throughout the program
static int x = 5;
}
return &x;
}
int main()
{
int *p = fun();
fflush(stdin);
// Not a dangling pointer as it points
// to static variable.
printf("%d", *p);
Now x is static, store in global memory, not
in local or stack memory
x=5
1.00
p=fun() = 100
300
printf *p → 5
Output:
5
Int *fun()
Int main()
X=5
100
Global memory,
not localVoid pointer ...
Void pointer - Is a type of pointer, not the value of pointer
#include<stdlib.h>
int main()
{
}
int x = 4;
float y
=
5.5;
//A void pointer
void *ptr;
ptr = &x;
// (int*)ptr - does type casting of void
// *((int*)ptr) dereferences the typecasted
// void pointer variable.
printf("Integer variable is = %d", *( (int*) ptr) );
// void pointer is now float
ptr = &y;
printf("\nFloat variable is= %f", *( (float*) ptr) );
return 0;
Void pointer can store address of any data
type.
To fetch the value of that data type, we
have to type cast it.
Output:
4
5.5Null Pointer - Is a value of a pointer
Wild pointer - Uninitialized value of a pointer
#include <stdio.h>
int main()
{
}
// Null Pointer
int *ptr = NULL;
}
printf("The value of ptr is %u", ptr);
return 0;
int main()
{
int *p; /* wild pointer */
int x = 10;
// p is not a wild pointer now
p = &x;
return 0;DG
Thank you for watching!
Please leave us your comments.