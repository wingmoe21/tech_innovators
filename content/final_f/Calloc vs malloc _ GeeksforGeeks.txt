Transcript of the audio for the lecture:
0.989 - 5.271:  Hello friends, today in this video we will discuss about Kellogg versus malloc.
6.691 - 7.492: So, let us start.
8.372 - 14.734: So, both malloc and Kellogg functions are library functions that allocate memory dynamically.
15.754 - 22.577: It means memory is allocated during run time or we can say during execution of the program.
23.457 - 28.339: This memory will be provided to us from heap segment.
30.731 - 40.117:  So, now we will see what are the initialization, what are the number of arguments and what is the return value of these functions.
41.798 - 44.52: So, first of all we will see malloc initialization.
45.841 - 49.904: So, see malloc function needs only one argument which is size.
50.824 - 59.39: It means how many byte you want to allocate during runtime and let us assume it has allocated
60.899 - 89.308:  four blocks so in each block it will fill a garbage value okay but in calloc see it needs two arguments one is the size or we can say number of blocks and other argument will be what is the size for each block okay
90.262 - 96.227:  And in the initialization part, let us assume we have allocated three blocks.
97.608 - 97.869: Okay.
98.489 - 102.913: So in each block, it will fill zero as the initialization value.
104.634 - 106.756: So this is the difference between malloc and calloc.
107.637 - 116.044: Malloc will fill garbage value as the initialization part and calloc will fill zero as the initialization part.
118.976 - 148.079:  what will be the return value of this function so after successful allocation in malloc and calloc a pointer to the block of memory is returned otherwise null value is returned which indicates the failure of allocation ok so let us carefully watch this program we will see what it is doing so in the main method we have defined
149.13 - 176.342:  pointer to an integer which is r okay now what we are doing using malloc function we are taking 5 into 4 size of int is 4 so 5 into 4 20 so 20 bytes we are taking at the run time from where from the heap segment so these 20 bytes we have taken
177.478 - 179.98:  ok these are 20 bytes which we have taken.
182.221 - 191.287: So, in each 20 bytes what malloc will do it will fill a garbage value like this ok.
193.429 - 198.372: After that what we are doing we are freeing using air pointer.
198.412 - 199.152: So, what is air?
199.953 - 205.737: Air is a pointer which is directing to this block of memory which is 20 bytes.
207.267 - 214.411:  So what free function will do, free function will deallocate this memory from the heap segment.
217.293 - 224.877: After that what we are doing, again using this air pointer only and calloc function.
226.077 - 228.619: Again we are taking 20 bytes.
230.88 - 231.16: Ok.
232.761 - 233.942: And what are the number of blocks?
233.962 - 235.563: 5 is the number of blocks.
237.424 - 251.047:  2, 3, 4, 5 and size of int will be 4 means each block will be of 4 bytes and it will provide 0 as the value instead of garbage.
253.148 - 253.408: Okay.
254.828 - 264.271: After that what we are doing we are freeing using air pointer so again air is directing to the first block of this memory.
265.191 - 266.291: So when we will use
267.136 - 276.579:  free function what it will do again it will remove this memory from the heap segment ok then we are returning from the function.
277.959 - 281.96: So, this is how this malloc and calloc functions can be used.
284.961 - 290.542: Now in this slide we will see which one is better malloc function or calloc function.
291.543 - 295.724: So, but before discussing this what we will see
296.641 - 307.006:  We will see that we can use malloc function also instead of calloc to initialize each block to zero as a value.
308.086 - 308.306: How?
309.006 - 311.888: First of all, we will allocate some memory using malloc.
313.148 - 315.589: After that, we will use memset.
316.65 - 316.93: Okay.
317.41 - 320.511: And using memset, we will provide zero as the value.
320.872 - 322.092: So, what this function will do?
322.812 - 326.194: It will initialize zero as the value for each block.
328.075 - 333.618:  So if we will combine these both steps, these are equivalent to Kellogg function.
335.499 - 335.759: Okay.
337.1 - 338.4: So now let us read the note.
339.601 - 349.086: It would be better to use malloc over Kellogg unless we want the zero initialization because malloc is faster than Kellogg.
350.086 - 357.67: So if you just want to copy some stuff or do something that does not require filling of the blocks with zeros.
358.206 - 359.827:  then malloc would be a better choice.
361.148 - 366.393: So, what this note is saying that malloc is much much faster than calloc function.
367.954 - 384.928: So, if you do not want initialization values as 0 then you should use malloc function otherwise you can also use calloc functions if you do not care about performance of the program ok.
386.581 - 387.485:  Thank you for watching.
387.727 - 388.872: Please leave us your comments.


The content from the lecture slides:
Page1: This slide provides an introductory explanation of double pointers in C programming. A double pointer is a pointer that points to another pointer, thereby being able to indirectly access the value of a variable. The slide gives an example with variable `a` holding a value of 80, pointer `p` containing the address of `a`, and pointer `q` containing the address of `p`. Dereferencing `q` once gives the address of `a`, and dereferencing `q` twice gives the value of `a`.

Page2: This slide presents an example of a C program demonstrating the use of pointer-to-pointer. The program defines a variable `var` with a value of 789, and two pointer variables, `*ptr2` and `**ptr1`. `ptr2` is assigned the address of `var`, and `ptr1` is assigned the address of `ptr2`. The output shows how the value of `var` can be accessed using both the single pointer `*ptr2` and double pointer `**ptr1`.

Page3: The third slide displays a screenshot of Microsoft PowerPoint in editing view, showing the second slide of the presentation, which is the same as described for Page 2.

Page4: The fourth slide is identical to the third slide, with a greyed-out effect, indicating a duplicated or unused slide.

Page5: This slide displays a simple C program, demonstrating the printing of a variable's address. The variable `x` is declared without initialization, and its address is printed using the `printf` function and the `%p` format specifier. The example makes it apparent that addresses can differ between program runs due to the nature of how memory is allocated.

Page6: The sixth slide shows another C program example that explains how to declare a pointer variable and print the address and value of an integer variable using that pointer. The sample code demonstrates declaring an integer variable `Var`, setting it to 10, then creating a pointer `ptr` that stores the address of `Var`. It prints both the value and the address stored in `ptr`.

Page7: This slide illustrates a sample C++ program that demonstrates pointer arithmetic. An integer array `v` is declared along with a pointer `ptr`. The program shows how we can iterate through the array using the pointer. With each iteration, the pointer is incremented using the `ptr++` command, and it prints the value and the address held by the pointer, demonstrating how pointers can be used to traverse arrays.

Page8: The final slide thanks viewers for watching the presentation, inviting them to leave their comments. It serves as a closing remark slide for the presentation.
Size of dynamically allocated memory can be changed by using realloc().
void *realloc(void *ptr, size_t size);
realloc deallocates the old object pointed to by ptr and returns a pointer to a new object that has the size
specified by size. The contents of the new object is identical to that of the old object prior to deallocation, up
to the lesser of the new and old sizes. Any bytes in the new object beyond the size of the old object have
indeterminate values.
The point to note is that realloc() should only be used for dynamically allocated memory. If the memory
is not dynamically allocated, then behavior is undefined.#include <stdio.h>
#include <stdlib.h>
int main()
{
}
int arr[2], i;
int *ptr = arr;
int *ptr_new;
arr[0] = 10;
arr[1] = 20;
// incorrect use of new_ptr: undefined behaviour
ptr_new = (int *)realloc(ptr, sizeof(int)*3);
*(ptr_new + 2) = 30;
for(i = 0; i < 3; i++)
printf("%d ", *(ptr_new + i));
getchar();
return 0;#include <stdio.h>
#include <stdlib.h>
int main()
{
}
int *ptr = (int *)malloc(sizeof(int)*2);
int i;
int *ptr_new;
*ptr = 10;
*(ptr + 1) = 20;
ptr_new = (int *)realloc(ptr, sizeof(int)*3);
*(ptr_new + 2) = 30;
for (i = 0; i < 3; i++)
printf("%d ", *(ptr_new + i));
getchar();
return 0;DG
Thank you for watching!
Please leave us your comments.