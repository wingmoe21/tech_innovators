Transcript of the audio for the lecture:
0.759 - 8.884:  Hello friends today in this video we will discuss about how does free method knows the size of memory to be deallocated.
10.065 - 10.905: So let us start.
12.266 - 26.255: As we have discussed in the previous videos that what malloc will do, how it will initialize the memory into the heap memory and if we will not free the allocated memory then what is the problem.
27.896 - 30.298: So see
31.328 - 32.628:  This is our malloc function.
33.469 - 38.55: It is initializing the memory of 4 bytes because integer is of 4 bytes.
39.671 - 49.794: Then it is typecasting into int star because we want to store this address into a pointer which is of type integer.
50.994 - 54.715: Then we are using some logic and we are returning from the function.
55.655 - 60.577: We are not freeing the memory which we have allocated using this malloc function.
62.202 - 74.746:  So, what we have discussed that using free method we can uninitialize this memory or we can say we can free the memory which we have allocated.
76.346 - 84.108: So, the question is how free get to know that how many bytes it has to free from the heap memory.
85.469 - 85.669: Okay.
87.441 - 116.933:  for that first of all we will see how malloc initialize the memory in the heap ok so see this is our heap memory so when we will use malloc function and we will give size of int what it will do it will give us 4 bytes memory ok so this is 4 bytes memory so this is the first
117.452 - 146.871:  byte address and this address will be stored into a void pointer and we will typecast this void pointer into int star okay because we want to store into a ptr pointer which is of type integer okay so while initializing this four bytes memory what malloc will do it will take another one word in the memory
148.143 - 176.271:  okay and it will store the size of the memory which we have allocated using malloc so like 4 so size is equal to 4 so when we will use free function to deallocate this memory we will provide the ptr pointer so this ptr pointer will contain the first byte address and using this word this free pointer
176.983 - 183.688:  or we can say free function will get to know that we have to deallocate 4 bytes from the memory.
184.869 - 192.855: So after this specified address it will go towards 4 bytes.
193.996 - 196.498: Okay and it will free this memory.
198.88 - 201.162: So there will not be any wastage of memory.
202.983 - 205.225: This free function is very very important.
206.434 - 217.86:  So the main logic is whenever memory allocation is done, the actual heap space allocated is one word larger than the requested memory.
218.941 - 226.285: And the extra word is used to store the size of the allocation and will be later used by free function.
229.607 - 230.507: Thank you for watching.
230.807 - 231.908: Please leave us your comments.


The content from the lecture slides:
Page1: The slide discusses the concept of a 'Dangling pointer,' which is a pointer that points to a memory location that has been deallocated or freed. For instance, deallocating memory using the 'free()' function and then attempting to access the memory through the pointer leads to a dangling pointer. The slide gives an example in C language, where a pointer 'ptr' is allocated memory using 'malloc' and then freed using 'free(ptr)'. To prevent the pointer from becoming a dangling pointer, it is set to 'NULL' after being freed.

Page2: This slide explains that a pointer becomes dangling when it points to a local variable that is not static, as the memory for the local variable is no longer valid after the function execution is complete. The example code defines a function 'fun()' that returns the address of a local variable 'int x'. This results in a dangling pointer when 'main()' calls 'fun()' and assigns its return value to 'int *p', as the local variable 'x' goes out of scope when 'fun()' returns, making the memory location invalid.

Page3: The slide continues the discussion around dangling pointers and shows that if the local variable is made 'static', the problem of the dangling pointer is resolved. When 'fun()' is called now, it returns the address of the static local variable 'int x', which has the scope throughout the program execution. Therefore, the pointer 'int *p' in 'main()' is no longer dangling and points to a valid memory location holding the value '5'.

Page4: This slide introduces the concept of a 'Void pointer' and points out that it is a type of pointer but does not hold the value of the pointer. It explains that void pointers can store the address of any data type and that typecasting is required to fetch the value of that data type. The code snippet illustrates how to cast a void pointer to int and float to print the values of different variables.

Page5: This slide covers 'Null Pointer' and 'Wild pointer'. A null pointer is a pointer with a value NULL, which means it points to nothing, while a wild pointer is uninitialized and can cause problems if dereferenced. Two code examples show how to declare a null pointer and how to initialize a wild pointer to prevent it from being wild.
Most of the time, pointer and array accesses can be treated as acting
the same, the major exceptions being:
• the sizeof operator
sizeof(array) returns the amount of memory used by all elements in
array
sizeof(pointer) only returns the amount of memory used by the
pointer variable itself
• the & operator
&array is an alias for &array[0] and returns the address of the first
element in array
&pointer returns the address of pointera string literal initialization of a character array
char array[] = "abc" sets the first four elements in array to ‘a', 'b', 'c',
and '\0'
char *pointer = “abc" sets pointer to the address of the "abc" string
(which may be stored in read-only memory and thus unchangeable)
• Pointer variable can be assigned a value whereas array variable
cannot be.int array[4]
=
char arr[] =
char *ptr =
1
100
a
100
a
100
2
104
b→→z
101
b
101
sizeof(array) → 16
array → 100 ➜ &array → 100
char arr[] = "abc"
char *ptr = "abc"
arr 100
(arr+1) ⇒ 101 → *(arr+1) = z
*(ptr+1) = z -> throw an error, stored in read only memory
arr = 98 → throw an error
3
108
C
102
C
102
4
112
\0
103
\0
103
ptr = 100
1000a string literal initialization of a character array
char array[] = "abc" sets the first four elements in array to ‘a', 'b', 'c',
and '\0'
char *pointer = "abc" sets pointer to the address of the “abc" string
(which may be stored in read-only memory and thus unchangeable)
• Pointer variable can be assigned a value whereas array variable
cannot be.int array[4]
=
char arr[] =
char *ptr =
1
100
a
100
a
100
2
104
b→→z
101
bz
101
sizeof(array) → 16
array → 100 ➜ &array → 100
char arr[] = "abc"
char *ptr = "abc"
arr 100
(arr+1) → 101 → *(arr+1) = z
*(ptr+1) = z -> throw an error, stored in read only memory
arr = 98 → throw an error
3
108
C
102
C
102
4
112
\0
103
\0
103
ptr = 100
1000DG
O
Thank you for watching!
Please leave us your comments.