Transcript of the audio for the lecture:
0.256 - 0.856:  Hello friends!
1.216 - 2.457: Welcome to GeeksforGeeks.
3.037 - 8.458: In this tutorial, we are going to see how to convert a decimal number into an octal number.
8.918 - 10.759: Let us look at the problem statement.
11.719 - 19.642: Given a decimal number as input, we need to write a program to convert the given decimal number into equivalent octal number.
20.742 - 24.483: That is, convert the number with base value 10 to base value 8.
25.228 - 31.43:  The base value of a number system determines the number of digits used to represent a numeric value.
32.17 - 36.152: For example, the binary number uses 2 digits 0 and 1.
36.752 - 46.335: Octal number system uses 8 digits from 0 to 7 and decimal number system uses 10 digits from 0 to 9 to represent any numeric value.
46.916 - 48.536: Now let us look at the algorithm.
48.976 - 49.256: Step 1.
49.997 - 53.438: Store the remainder when the number is divided by 8 in an array.
54.122 - 54.923:  Step 2.
55.143 - 56.164: Divide the number by 8.
57.184 - 58.125: Step 3.
58.345 - 61.707: Repeat the above two steps until the number is not equal to 0.
62.768 - 63.669: Step 4.
63.889 - 65.89: Reprint the array in reverse order.
66.371 - 68.252: Let us understand this with an example.
68.933 - 70.774: Suppose the decimal number is 33.
71.374 - 72.255: Step 1.
72.755 - 78.279: We store the remainder that is obtained when 33 is divided by 8 into the array, i.e., 1.
79.52 - 80.601: Now, Step 2.
81.101 - 83.283: We divide 33 by 8, which gives 4.
84.312 - 86.893:  As the number is not 0, we continue this step.
86.913 - 92.095: 4 divided by 8 will give quotient 0 and remainder is stored in the array which is 4.
93.115 - 96.796: Now as the number is 0, we print the array in reverse order.
97.256 - 99.877: Therefore, its octal equivalent will be 41.
100.437 - 101.738: Now let us look at the code.
102.158 - 107.78: In the function decimalToOctal, we have passed a decimal number and it prints its octal equivalent.
108.54 - 111.141: Octal number is an array to store the octal number.
111.621 - 113.382: We initialize the counter i with 0.
114.235 - 117.497:  Now we run a while loop until n is not equals to 0.
118.318 - 125.723: First of all, we will find the remainder of n when it is divided by 8 and store it into the ith position of the octal number array.
126.243 - 130.206: Then we will actually divide the number by 8 and increase i by 1.
131.006 - 134.248: These three steps will happen until n is not equals to 0.
134.708 - 138.131: In the end, we will print the octal number array in reverse order.
138.911 - 140.412: Let us see this with an example.
140.953 - 142.333: Let the decimal number be 33.
143.712 - 149.155:  Initially, the octal number array will be empty and the value of i will be initialized with 0.
149.855 - 153.838: As the value of n is not equal to 0, we enter the while loop.
154.158 - 160.141: We store the remainder of n when divided by 8 into the octal number array i.e.
160.161 - 165.604: 33 divided by 8 gives us 1 and we store it in the ith position of the octal number array.
166.324 - 168.005: Now n will be divided by 8 i.e.
168.025 - 169.086: 33 divided by 8 gives us 4.
171.681 - 173.782:  and we increase the value of i by 1.
174.222 - 178.263: As the value of n is still not equal to 0, we continue the while loop.
178.763 - 185.325: Again n modulus 8 that is 4 modulus 8 will give us 4 and we store it in the octal number array.
185.745 - 191.466: Now we divide 4 by 8 which gives us 0 and we increase the value of i by 1 to 2.
192.007 - 199.609: Now as the value of n is equal to 0, we exit the while loop and print the octal number array in reverse order that is 41.
201.135 - 202.558:  I hope you understood the code.
203.018 - 204.0: Thank you for watching.
204.18 - 205.343: Please leave us your comments.


The content from the lecture slides:
Page 1: Registers provide faster access compared to memory, so in C programming, frequent-use variables can be designated for register storage with the "register" keyword. However, whether a variable actually gets stored in a register is at the compiler’s discretion, and modern compilers typically handle this optimization themselves without the keyword.

Page 2: Attempting to use the address-of operator (&) on a register variable can lead to an error or a warning, since register variables are stored in the CPU's registers, not in memory where addresses are relevant. The example program provided illustrates this misuse, which would likely cause a compiler error.

Page 3: The keyword "register" can also be applied to pointers. Since registers can store the address of a memory location, there would not be an issue if the "register" keyword is used with a pointer that holds the address of an integer, as shown in the provided example program.

Page 4: You cannot use "register" together with "static" or other storage class specifiers on the same variable because C does not permit multiple storage class specifiers for a single variable. There is no fixed limit to the number of register variables you can declare, but the actual number of variables that can be held in registers is determined by the compiler and the architecture’s capabilities. The example shows incorrect usage that would likely lead to a compilation error due to the combined storage class specifiers.

Page 5: This page appears to be a closing slide with a thank you message for viewing the presentation. No further information related to the lecture content is provided.
The name malloc and calloc() are library functions that allocate memory dynamically. It means that memory is
allocated during runtime(execution of the program) from heap segment.
Initialization: void * malloc( size_t size );
malloc() allocates memory block of given size (in bytes) and returns a pointer to the beginning of the block.
malloc() doesn't initialize the allocated memory. If we try to acess the content of memory block then we'll get
garbage values.
calloc() allocates the memory and also initializes the allocates memory block to zero. If we try to access the
content of these blocks then we'll get 0.
Number of arguments: Unlike malloc(), calloc() takes two arguments: void * calloc( size_t num, size_t size );
Number of blocks to be allocated.
Size of each block.
Return Value: After successful allocation in malloc() and calloc(), a pointer to the block of memory is returned
otherwise NULL value is returned which indicates the failure of allocation.// C program to demonstrate the use of calloc()
// and malloc()
#include <stdio.h>
#include <stdlib.h>
int main()
{
}
int *arr;
// malloc() allocate the memory for 5 integers
// containing garbage values
arr = (int *)malloc(5 * sizeof(int)); // 5*4bytes = 20 bytes
// Deallocates memory previously allocated by malloc() function
free( arr);
// calloc() allocate the memory for 5 integers and
// set 0 to all of them
arr = (int *)calloc(5, sizeof(int));
// Deallocates memory previously allocated by calloc() function
free (arr);
return(0);We can achieve same functionality as calloc() by using malloc() followed by memset().
ptr = malloc(size);
memset(ptr, 0, size);
Note:
It would be better to use malloc over calloc, unless we want the zero-initialization because malloc is
faster than calloc. So if we just want to copy some stuff or do something that doesn't require filling of
the blocks with zeros, then malloc would be a better choice.DG
Thank you for watching!
Please leave us your comments.