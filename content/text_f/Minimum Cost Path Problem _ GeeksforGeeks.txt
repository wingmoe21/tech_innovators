Problem Statement :
Given :
A cost matrix cost[] (All costs are positive)
O Position (m, n) in cost[][]
O
Write a function that returns cost of minimum cost path to reach (m, n) from
(0, 0).
O
Total cost of a path to reach (m, n) is sum of all the costs on that path
(including both source and destination)Allowed movements :
Can only traverse up, right and diagonally upper cells from a given cell.
From a given cell (i, j)
(i+1,
(i, j+1)
(i+1, j+1)
A A A
j)2
1
0
1
4
1
0
5
8
2
1
2
3
2
31
4
1
5
8
2
3
2
3
Minimum cost:
1+2+2+3 = 8Optimal Substructure:
The path to reach (m, n) :
Through one of the 3 cells: (m-1, n-1) or (m-1, n) or (m, n-1).
→ minCost(m, n) = min (minCost(m-1, n-1), minCost(m-1, n), minCost(m, n-1))
+ cost[m][n]/* Returns cost of minimum cost path from (0,0) to (m, n
int minCost(int cost [R] [C], int m, int n)
{
|1}
if (n < 0 || m < 0)
return INT MAX;
else if (m == 0 && n == 0)
return cost [m][n];
else
return cost [m][n] + min( minCost (cost, m-1, n-1),
minCost(cost, m-1, n),
minCost (cost, m, n-1) );Time complexity of this naive
recursive solution is exponential!mC refers to minCost()
/
Overlapping Subproblems
/
mC (1, 1)
|
1
mC(2, 2)
I
|
mC (1, 2)
/
|
|
1
mC (0,0) mC (0,1) mC (1,0) mC (0,1) mC (0,2) mC (1,1) mC (1,0)
1
mC (2,
/
/
1)
1
|
|
mC (1,1) mC (2,0)So the problem has :
Optimal Substructure
and
Overlapping subproblems
Dynamic Programming
Constructing a temporary array t
in bottom up manner.2
1
О
1
4
1
О
5
8
2
1
2
3
2
32
1
1 4
0
1
0
Cost
5
8
2
1
3
2
3
2
2
İ ₁
1
0
0
1
tc
j
2{
}
int i, j;
// Instead of following line, we can use int tc[m+1] [n+1] or
// dynamically allocate memory to save space. The following line is
// used to keep the program simple and make it working on all compile
int tc[R] [C];
tc[0][0] = cost[0][0];
/* Initialize first column of total cost(tc) array */
for (i = 1; i <= m; i++)
tc[i][0] = tc[i-1][0] + cost[i][0];
/* Initialize first row of tc array */
for (j = 1; j <= n; j++)
tc[0][j] = tc[0][j-1] + cost[0][j];
/* Construct rest of the tc array */
for (i = 1; i <= m; i++)
for (j = 1; j <= n; j++)
tc[i][j] = min (tc[i-1] [j-1],
tc[i-1][j],
return tc[m][n];
tc[i][j-1]) + cost[i][j];Time
Complexity
0(m * n)Thank You for watching !
Please leave us your likes and comments.